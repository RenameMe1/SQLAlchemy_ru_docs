С объектом [[Engine]], готовым к работе, мы можем сейчас продолжить погрузиться в базовые операции с [[Engine]] и главными интерактивными конечными точками такими как [[Connectionn]] и [[Result]]. Мы будем дополнительно вводить ORM [[фасад]] для этих объектов, известный как [[Session]].

>[!ORM]
>При использовании ORM, [[Engine]] управляет другим объектом, называемым [[Session]]. [[Session]] в современной SQLAlchemy подчеркивает транзакционный и паттерн выполнения SQL, который значительно идентичен [[Connectionn]] обсужденный ниже, так пока эта подсекция ориентирована на Ядро, все концепты здесь по существу подходят для ORM использования и рекомендуется для всех ORM учащихся. Паттерн выполнения используемый [[Connectionn]] будет контрастировать с  [[Session]] в конце этого раздела.

Так как мы еще не успели представить язык выражений SQL, который основная особенность SQLAlchemy, мы будет использовать одну простую конструкцию в пределах этого пакета называемое [[text()]] конструкцией, которая позволяет нам писать SQL выражения как **текстовый SQL**. Будьте уверены, что текстовый SQL в повседневном использовании SQLAlchemy однозначно скорее исключение чем правило для большинства задач, даже несмотря на то, что он всегда остается полностью доступным.

> [!Core]
> # Получение подключения
> 
> Единственной целью объекта [[Engine]] из ориентированной на пользователя перспективе предоставить юнит соединения с базой данных, называемый [[Connectionn]].  При работе с ядром напрямую, объект [[Connectionn]] это как всё взаимодействуем с базой данных. Как [[Connectionn]] представляет открытый ресурс с базой данных, мы хотим всегда ограничить область нашего использования этого объекта определенным контекстом и лучший способ делать это используя форму контекст менеджера Python, так же известного как  [выражение with](https://docs.python.org/3/reference/compound_stmts.html#with).  Ниже мы показывает "Hello world" используя текстовое SQL выражение. Выпускаемый текстовый SQL  использует конструкцию называемую [[text()]] который будет обсуждаться в больших деталях позднее:
> ``` python
> 
>>>> from sqlalchemy import text
>
>>> with engine.connect() as conn:
...     result = conn.execute(text("select 'hello world'"))
...     print(result.all())
>----------------------------------------------------------------------
BEGIN (implicit)
select 'hello world'
[...] ()
>----------------------------------------------------------------------
>
[('hello world',)]
>
>----------------------------------------------------------------------
ROLLBACK
>----------------------------------------------------------------------
>```
> В примере выше, контекст менеджер предоставляет подключение к базе данных и так же оформляет внутреннюю операцию транзакции. Стандартное поведение Python DBAPI включает, что транзакция всегда в процессе; когда область подключения [[released]], ROLLBACK выполняется для окончания транзакции.  Транзакция **не совершается автоматически**; когда мы хотим зафиксировать данный мы обычно нуждается в вызове [[Connection.commit()]] как мы увидим в следующей секции.
> 
>> [!TIP]
>>Режим "autocommit" (автоматического фиксирования) доступен для особых случаев. Это обсуждается в секции  [[Setting Transaction Isolation Levels including DBAPI Autocommit]]
>
>Результат нашего SELECT будет так же возвращено в объекте называемым [[Result]], который будет обсужден позднее, однако на данный момент мы будем добавлять, что лучше всего обеспечит использование этого объекта  в области блока "connect" и не передается по наследству извне области нашего подключения.
>
>
>

>[!Core]
># Фиксирование изменений
>Мы только изучили, что подключение DBAPI не автофиксирующее. Что если мы хотим зафиксировать некоторую информацию? Мы можем изменить наш пример выше для создания таблицы и вставки некоторой информации, и транзакция затем зафиксируется используя метод [[Connection.commit()]], вызываемого **внутри** блока где мы получили объект [[Connectionn]]:
>
>``` python
># "фиксация по ходу дела"
>>> with engine.connect() as conn:
...     conn.execute(text("CREATE TABLE some_table (x int, y int)"))
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
...     )
...     conn.commit()
>------------------------------------------------------------------
BEGIN (implicit)
CREATE TABLE some_table (x int, y int)
[...] ()
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(1, 1), (2, 4)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
>------------------------------------------------------------------
>```
> 
> 
> Выше мы выпускаем два SQL выражения, которые обычно транзакционные, "CREATE TABLE" выражение и "INSERT" выражение, которое параметризированное (Параметризированный выше синтаксис обсуждается в нескольких секциях ниже в [[Отправка множественных параметров]]). Так как мы хотим, что бы наша работа зафиксировалась, она должна быть выполнена в пределах нашего блока, мы вызываем метод [[Connection.commit()]], который фиксирует транзакцию. После мы вызываем этот метод внутри блока, мы может продолжить выполнение других SQL выражений и если мы захотим, мы можем вызвать [[Connection.commit()]] снова, для последующих выражений. SQLALchemy называет этот стиль **фиксацией по ходу выполнения (commit as you go)**.
>
>Есть также другой стиль фиксирования данных, который мы можем объявить в нашем блоке "connect" блоком транзакции спереди. Для этого режима операции, мы используем метод [[Engine.begin()]] получения подключения, вместо [[Engine.connect()]] метода. Этот метод будет и управлять областью [[Connectionn]] и также заключать все внутренние транзакции с COMMIT в конце, предполагая блок завершенный успешно или ROOLBACK в случае возникновения исключения. Этот стиль известен как **начните один раз (begin once)**
>``` python
># "begin once"
>>> with engine.begin() as conn:
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 6, "y": 8}, {"x": 9, "y": 10}],
...     )
> -----------------------------------------------------------------
BEGIN (implicit)
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(6, 8), (9, 10)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
> -----------------------------------------------------------------
>```
>
>
Стиль "Begin once" часто предпочтителен так как он более краток и обозначает цель впереди всего блока. Однако, в пределах этого руководства мы будет обычно использовать стиль "commit as you go" так как он более гибкий для демонстрационный целей.
>>[!quote]
>> Что такое "Begin (implicit)"?
>> Вы вероятно заметили строку лога "Begin (implicit)" как начало блока транзакции. "implicit" здесь означает, что SQLAlchemy **на самом деле не отправляет любые команды** в базу данных; она просто считает это в началом неявной DBAPI транзакции. Вы можете оформить [[крюки события]] для перехвата этого события, для примера.
>
> [[DDL]] ссылается на подмножество SQL, которое инструктирует базу данных для создания, модификации и удаления конструкций уровня схемы таких как таблицы. Такой DDL как "CREATE TABLE" рекомендуется быть в пределах транзакционного блока, который кончается "COMMIT", так как много баз данных использует транзакционный DDL, так что  изменения схемы не принимаются до фиксации транзакции. Однако, как мы увидим позднее, мы обычно позволяем SQLAlchemy запускать DDL последовательности для нас как часть операции высокого уровня, где нам обычно не надо беспокоится относительно COMMIT. 

>[!CORE]
># Основы выполнения выражения
>
>Мы увидели немного примеров, которые запускают SQL выражения для базы данных,
>используя метод называемый [[Connection.execute()]], в союзе с объектом называемым
>[[text()]] и возвращающий объект называемый [[Result]]. В этой секции мы будем
>рассматривать более закрытый механизм и взаимодействие с этими компонентами.
>
>>[!ORM]
>>Большинство содержимого этой секции применяется одинаково хорошо в современном
>>использовании ORM при использовании [[Session.execute()]], который работает очень
>>похоже что и [[Connection.execute()]], включая тот же строковый ORM результат
>>добавленный
>>использованием того же интерфейса [[Result]] используемого в ядре.
>>[!ORM]
>># Получение строк
>>
>>Мы будем первым показывать объект [[Result]] более внимательно используя строки,
>>которые
>>мы вставили ранее. выполнение текстового SELECT выражения на таблицу которую мы
>>создали:
>>
>> ``` python
>> >>> with engine.connect() as conn:
>>...     result = conn.execute(text("SELECT x, y FROM some_table"))
>>...     for row in result:
>>...         print(f"x: {row.x}  y: {row.y}")
>> | ------------------------------------------------------------------
>>BEGIN (implicit)
>>SELECT x, y FROM some_table
>> […] ()
>> |------------------------------------------------------------------
>>
>>x: 1  y: 1
>>x: 2  y: 4
>>x: 6  y: 8
>>x: 9  y: 10
>>
>> |------------------------------------------------------------------
>>ROLLBACK
>> |------------------------------------------------------------------
>>```
>>
>>Выше, нами выполненная строка "Select" выбрала все строки из нашей таблицы.
>>Возвращенный объект называется [[Result]] и предоставляет итерируемый объект строк
>>результата.
>>
>>[[Result ]] имеет много методов для получения и трансформации строк, такие как метод
>>[[Result.all()]] показанный ранее, который возвращает список всех [[Row]] объектов. Он так
>>же реализует интерфейс итератора Python, так что, мы можем перебирать через
>>коллекцию строк [[Row]] объекта напрямую. Сами объекты [[Row]] предназначены для
>>того, чтобы действовать подобно [[именованным кортежам]] Python. Ниже мы показали
>>разнообразие способов для доступа к строкам.
>>
>>- **Назначение кортежа** - Это более Python-идеамотический стиль, который назначает
>>переменные каждой строке позиционно как они получены:
>>``` python
>>result = conn.execute(text("select x, y from some_table"))
>>
>>for x, y in result:
>>    …
>>```
>>
>>- **Целочисленный индекс** - Кортежи это  Python последовательности, так обычный
>>- целочисленный доступ также доступен
>>
>>``` python
>>result = conn.execute(text("select x, y from some_table"))
>>
>>for row in result:
>>    x = row[0]
>>```
>>
>>- **Имя атрибута** - Так как это Python именованные кортежи, кортежи имеют
>>динамические имена атрибутов сопоставляемые с именами каждой колонны. Эти имена
>>обычно имена которые SQL выражение назначит колоннам в каждой строке. Пока они
>>обычно довольно предсказуемые и могут так же быть под контролем меток, в
>>наименьшем количестве описанных случаев они могут быть предметом поведения
>>специфичного для базы данных:
>>
>>``` python
>> result = conn.execute(text("select x, y from some_table"))
>>
>>for row in result:
>>    y = row.y
>>
>>    # Демонстрация использования Python f-строк
>>    print(f"Row: {row.x} {y}")
>>
>>```
>>
>>- **Сопоставление доступа** - Для получения строк как сопоставленные Python объекты,
>>которые по существу версия, ограниченная только чтением, Python интерфейса
>>общеизвестного объекта `dict`, [[Result]] может быть **преобразован** в объект
>>[[MappingResult]] используя модификатор [[Result.mappings()]]; этот объект результата,
>>который выдает объект [[RowMapping]] который поход на словарь, вместо объекта [[Row]]:
>>
>>``` python
>>result = conn.execute(text("select x, y from some_table"))
>>
>>for dict_row in result.mappings():
>>    x = dict_row["x"]
>>    y = dict_row["y"]
>>```



