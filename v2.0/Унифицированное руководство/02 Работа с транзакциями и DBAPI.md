С объектом [[Engine]], готовым к работе, мы можем сейчас продолжить погрузиться в базовые операции с [[Engine]] и главными интерактивными конечными точками такими как [[Connectionn]] и [[Result]]. Мы будем дополнительно вводить ORM [[фасад]] для этих объектов, известный как [[Session]].

>[!ORM]
>При использовании ORM, [[Engine]] управляет другим объектом, называемым [[Session]]. [[Session]] в современной SQLAlchemy подчеркивает транзакционный и паттерн выполнения SQL, который значительно идентичен [[Connectionn]] обсужденный ниже, так пока эта подсекция ориентирована на Core, все концепты здесь по существу подходят для ORM использования и рекомендуется для всех ORM учащихся. Паттерн выполнения используемый [[Connectionn]] будет контрастировать с  [[Session]] в конце этого раздела.

Так как мы еще не успели представить язык выражений SQL, который основная особенность SQLAlchemy, мы будет использовать одну простую конструкцию в пределах этого пакета называемое [[text()]] конструкцией, которая позволяет нам писать SQL выражения как **текстовый SQL**. Будьте уверены, что текстовый SQL в повседневном использовании SQLAlchemy однозначно скорее исключение чем правило для большинства задач, даже несмотря на то, что он всегда остается полностью доступным.
# Получение подключения
> [!Core]
> 
> 
> Единственной целью объекта [[Engine]] из ориентированной на пользователя перспективе предоставить юнит соединения с базой данных, называемый [[Connectionn]].  При работе с Core напрямую, объект [[Connectionn]] это как всё взаимодействуем с базой данных. Как [[Connectionn]] представляет открытый ресурс с базой данных, мы хотим всегда ограничить область нашего использования этого объекта определенным контекстом и лучший способ делать это используя форму контекст менеджера Python, так же известного как  [выражение with](https://docs.python.org/3/reference/compound_stmts.html#with).  Ниже мы показывает "Hello world" используя текстовое SQL выражение. Выпускаемый текстовый SQL  использует конструкцию называемую [[text()]] который будет обсуждаться в больших деталях позднее:
> ``` python
> 
>>>> from sqlalchemy import text
>
>>> with engine.connect() as conn:
...     result = conn.execute(text("select 'hello world'"))
...     print(result.all())
>----------------------------------------------------------------------
BEGIN (implicit)
select 'hello world'
[...] ()
>----------------------------------------------------------------------
>
[('hello world',)]
>
>----------------------------------------------------------------------
ROLLBACK
>----------------------------------------------------------------------
>```
> В примере выше, контекст менеджер предоставляет подключение к базе данных и так же оформляет внутреннюю операцию транзакции. Стандартное поведение Python DBAPI включает, что транзакция всегда в процессе; когда область подключения [[released]], ROLLBACK выполняется для окончания транзакции.  Транзакция **не совершается автоматически**; когда мы хотим зафиксировать данный мы обычно нуждается в вызове [[Connection.commit()]] как мы увидим в следующей секции.
> 
>> [!TIP]
>>Режим "autocommit" (автоматического фиксирования) доступен для особых случаев. Это обсуждается в секции  [[Setting Transaction Isolation Levels including DBAPI Autocommit]]
>
>Результат нашего SELECT будет так же возвращено в объекте называемым [[Result]], который будет обсужден позднее, однако на данный момент мы будем добавлять, что лучше всего обеспечит использование этого объекта  в области блока "connect" и не передается по наследству извне области нашего подключения.
>
>
>
# Фиксирование изменений
>[!Core]
>
>Мы только изучили, что подключение DBAPI не автофиксирующее. Что если мы хотим зафиксировать некоторую информацию? Мы можем изменить наш пример выше для создания таблицы и вставки некоторой информации, и транзакция затем зафиксируется используя метод [[Connection.commit()]], вызываемого **внутри** блока где мы получили объект [[Connectionn]]:
>
>``` python
># "фиксация по ходу дела"
>>> with engine.connect() as conn:
...     conn.execute(text("CREATE TABLE some_table (x int, y int)"))
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 1, "y": 1}, {"x": 2, "y": 4}],
...     )
...     conn.commit()
>------------------------------------------------------------------
BEGIN (implicit)
CREATE TABLE some_table (x int, y int)
[...] ()
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(1, 1), (2, 4)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
>------------------------------------------------------------------
>```
> 
> 
> Выше мы выпускаем два SQL выражения, которые обычно транзакционные, "CREATE TABLE" выражение и "INSERT" выражение, которое параметризированное (Параметризированный выше синтаксис обсуждается в нескольких секциях ниже в [[Отправка множественных параметров]]). Так как мы хотим, что бы наша работа зафиксировалась, она должна быть выполнена в пределах нашего блока, мы вызываем метод [[Connection.commit()]], который фиксирует транзакцию. После мы вызываем этот метод внутри блока, мы может продолжить выполнение других SQL выражений и если мы захотим, мы можем вызвать [[Connection.commit()]] снова, для последующих выражений. SQLALchemy называет этот стиль **фиксацией по ходу выполнения (commit as you go)**.
>
>Есть также другой стиль фиксирования данных, который мы можем объявить в нашем блоке "connect" блоком транзакции спереди. Для этого режима операции, мы используем метод [[Engine.begin()]] получения подключения, вместо [[Engine.connect()]] метода. Этот метод будет и управлять областью [[Connectionn]] и также заключать все внутренние транзакции с COMMIT в конце, предполагая блок завершенный успешно или ROOLBACK в случае возникновения исключения. Этот стиль известен как **начните один раз (begin once)**
>``` python
># "begin once"
>>> with engine.begin() as conn:
...     conn.execute(
...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
...         [{"x": 6, "y": 8}, {"x": 9, "y": 10}],
...     )
> -----------------------------------------------------------------
BEGIN (implicit)
INSERT INTO some_table (x, y) VALUES (?, ?)
[...] [(6, 8), (9, 10)]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
> -----------------------------------------------------------------
>```
>
>
Стиль "Begin once" часто предпочтителен так как он более краток и обозначает цель впереди всего блока. Однако, в пределах этого руководства мы будет обычно использовать стиль "commit as you go" так как он более гибкий для демонстрационный целей.
>>[!quote]
>> Что такое "Begin (implicit)"?
>> Вы вероятно заметили строку лога "Begin (implicit)" как начало блока транзакции. "implicit" здесь означает, что SQLAlchemy **на самом деле не отправляет любые команды** в базу данных; она просто считает это в началом неявной DBAPI транзакции. Вы можете оформить [[крюки события]] для перехвата этого события, для примера.
>
> [[DDL]] ссылается на подмножество SQL, которое инструктирует базу данных для создания, модификации и удаления конструкций уровня схемы таких как таблицы. Такой DDL как "CREATE TABLE" рекомендуется быть в пределах транзакционного блока, который кончается "COMMIT", так как много баз данных использует транзакционный DDL, так что  изменения схемы не принимаются до фиксации транзакции. Однако, как мы увидим позднее, мы обычно позволяем SQLAlchemy запускать DDL последовательности для нас как часть операции высокого уровня, где нам обычно не надо беспокоится относительно COMMIT. 

# Основы выполнения выражения
>[!CORE]
>
>
>Мы увидели немного примеров, которые запускают SQL выражения для базы данных,
>используя метод называемый [[Connection.execute()]], в союзе с объектом называемым
>[[text()]] и возвращающий объект называемый [[Result]]. В этой секции мы будем
>рассматривать более закрытый механизм и взаимодействие с этими компонентами.
>
>>[!ORM]
>>Большинство содержимого этой секции применяется одинаково хорошо в современном
>>использовании ORM при использовании [[Session.execute()]], который работает очень
>>похоже что и [[Connection.execute()]], включая тот же строковый ORM результат
>>добавленный
>>использованием того же интерфейса [[Result]] используемого в Core.
>>[!ORM]
>># Получение строк
>>
>>Мы будем первым показывать объект [[Result]] более внимательно используя строки,
>>которые
>>мы вставили ранее. выполнение текстового SELECT выражения на таблицу которую мы
>>создали:
>>
>> ``` python
>> >>> with engine.connect() as conn:
>>...     result = conn.execute(text("SELECT x, y FROM some_table"))
>>...     for row in result:
>>...         print(f"x: {row.x}  y: {row.y}")
>> | ------------------------------------------------------------------
>>BEGIN (implicit)
>>SELECT x, y FROM some_table
>> […] ()
>> |------------------------------------------------------------------
>>
>>x: 1  y: 1
>>x: 2  y: 4
>>x: 6  y: 8
>>x: 9  y: 10
>>
>> |------------------------------------------------------------------
>>ROLLBACK
>> |------------------------------------------------------------------
>>```
>>
>>Выше, нами выполненная строка "Select" выбрала все строки из нашей таблицы.
>>Возвращенный объект называется [[Result]] и предоставляет итерируемый объект строк
>>результата.
>>
>>[[Result ]] имеет много методов для получения и трансформации строк, такие как метод
>>[[Result.all()]] показанный ранее, который возвращает список всех [[Row]] объектов. Он так
>>же реализует интерфейс итератора Python, так что, мы можем перебирать через
>>коллекцию строк [[Row]] объекта напрямую. Сами объекты [[Row]] предназначены для
>>того, чтобы действовать подобно [[именованным кортежам]] Python. Ниже мы показали
>>разнообразие способов для доступа к строкам.
>>
>>- **Назначение кортежа** - Это более Python-идеамотический стиль, который назначает
>>переменные каждой строке позиционно как они получены:
>>``` python
>>result = conn.execute(text("select x, y from some_table"))
>>
>>for x, y in result:
>>    …
>>```
>>
>>- **Целочисленный индекс** - Кортежи это  Python последовательности, так обычный
>>- целочисленный доступ также доступен
>>
>>``` python
>>result = conn.execute(text("select x, y from some_table"))
>>
>>for row in result:
>>    x = row[0]
>>```
>>
>>- **Имя атрибута** - Так как это Python именованные кортежи, кортежи имеют
>>динамические имена атрибутов сопоставляемые с именами каждой колонны. Эти имена
>>обычно имена которые SQL выражение назначит колоннам в каждой строке. Пока они
>>обычно довольно предсказуемые и могут так же быть под контролем меток, в
>>наименьшем количестве описанных случаев они могут быть предметом поведения
>>специфичного для базы данных:
>>
>>``` python
>> result = conn.execute(text("select x, y from some_table"))
>>
>>for row in result:
>>    y = row.y
>>
>>    # Демонстрация использования Python f-строк
>>    print(f"Row: {row.x} {y}")
>>
>>```
>>
>>- **Сопоставление доступа** - Для получения строк как сопоставленные Python объекты,
>>которые по существу версия, ограниченная только чтением, Python интерфейса
>>общеизвестного объекта `dict`, [[Result]] может быть **преобразован** в объект
>>[[MappingResult]] используя модификатор [[Result.mappings()]]; этот объект результата,
>>который выдает объект [[RowMapping]] который поход на словарь, вместо объекта [[Row]]:
>>
>>``` python
>>result = conn.execute(text("select x, y from some_table"))
>>
>>for dict_row in result.mappings():
>>    x = dict_row["x"]
>>    y = dict_row["y"]
>>```
# Отправка параметров

> [!CORE]
> SQL выражения обычно сопровождаются данными, которые будут переданы с сами выражением, как мы увидели в предыдущем INSERT примере. Следовательно метод [[Connection.execute()]] так же принимает параметры, которые известны как [[bound parameters]]. Элементарным примером может оказаться если мы хотим ограничить наше SELECT выражение только для строк, которые советуют определенному критерию,  такому как строки где значение "y" были больше чем определенные значение которые переданы в функцию.
>
>Чтобы добиться этого, чтобы выражение SQL могло оставаться зафиксированным и тот драйвер мог должным образом очистить значение, мы добавляем критерий WHERE к нашему выражению, который присваивает новому параметру имя “y”; конструкция `text()` принимает их используя в формате двоеточие ":y".  Фактическое значение для ":y" затем передается как второй аргумент для [[Connection.execute()]] в виде словаря.
>
>``` python
>>>> with engine.connect() as conn:
>...     result = conn.execute(text("SELECT x, y FROM some_table WHERE y > :y"), {"y": 2})
>...     for row in result:
>...         print(f"x: {row.x}  y: {row.y}")
>
>|------------------------------------------------------------------
>BEGIN (implicit)
>SELECT x, y FROM some_table WHERE y > ?
>[...] (2,)
>|------------------------------------------------------------------
>
>x: 2  y: 4
>x: 6  y: 8
>x: 9  y: 10
>|------------------------------------------------------------------
>ROLLBACK
>|------------------------------------------------------------------
>```
>
>В записанном в журнале SQL результате, мы может видеть, что привязанный параметр :y был преобразован в знак вопроса, когда он будет отправлен в базу данных. Это из-за того, что драйвер SQLite базы данных использует формат называемый "qmark formater style", который является одним из шести различных форматов доступных спецификации DBAPI. SQLAlchemy абстрагирует эти форматы в один, который "назван" форматом использующий двоеточие.
>
>>[!QUOTE]
>>Как упомянуто в начале этой секции, текстовый SQL не стандартный способ нашей работы с SQLAlchemy. Однако, при использовании текстового SQL, буквенное Python значение,  даже не строковое токовое как целочисленное или дата, **никогда не следует напрямую преобразовывать в строку SQL**; параметр должен **всегда** использоваться. Это наиболее известно как избегание атак SQL инъекций, когда данные не заслуживают доверия. Однако это так же позволяет SQLAlchemy диалекту и/или DBAPI корректно обрабатывать входящие данные для серверной части. За пределами простых тестовых вариантов использования SQL запросов, SQLAlchemy Core Expression API иначе гарантирует, что Python буквенные значения передаются как связанные параметры где это необходимо.
# Отправка нескольких параметров
> [!CORE]
> 
В примере [[#Фиксирование изменений]], мы выполнили INSERT оператор, где оказалось, что мы способны на вставку множества строк в базу данных сразу. Для [[DML]] операторов таких как "INSERT", "UPDATE" и "DELETE", мы можем отправить **множества наборов параметров** в метод [[Connection.execute()]] переданные списком словарей вместо одиночного словаря, который показывает что одиночное SQL выражение должно быть вызвано несколько раз, один раз для каждого параметра набора.  Этот стиль выполнения известен как [[executemany]]:
>
>``` python 
>>>> with engine.connect() as conn:
>...     conn.execute(
>...         text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
>...         [{"x": 11, "y": 12}, {"x": 13, "y": 14}],
>...     )
>...     conn.commit()
>
>|------------------------------------------------------------------
>BEGIN (implicit)
>INSERT INTO some_table (x, y) VALUES (?, ?)
>[...] [(11, 12), (13, 14)]
><sqlalchemy.engine.cursor.CursorResult object at 0x...>
>COMMIT
>|------------------------------------------------------------------
>```
>
Операция выше это аналог выполнения предоставленного INSERT оператора, один раз для каждого параметра набора, за исключение того, что операция будет оптимизирована для лучшей производительности во многих строках.
>
Ключевое поведенческое различие между "execute" и "executemany" это то, что последний не поддерживает возвращение результирующих строк,  даже если выражение включает пункт RETURNING. Одно исключение для этого, это когда используется Core конструкция  [[insert()]], представленная позднее в этом руководстве как [[Использование INSERT оператора]], который также показывает использование RETURNING в методе [[insert.returning()]]. В таком случае, SQLAlchemy использует специфическую логику для реорганизации INSERT выражения так, что оно может быть вызвано для многих строк, сохраняя при этом поддержку RETURNING.
>
>>[!Quote]
>> # Смотрите так же
>> [[executemany]] - в [[Словарь]], описывает метод DBAPI уровня [[cursor.executemany()]]
>> которые используется для большинства “executemany” реализаций. 
>>
>> [[asda|"Insert Many Values" поведение для INSERT выражений]] - в [[Работа с Engines и Connectons]], описывает специализированную логику используемую в [[insert.returning()]] для доставки наборов результата с "executemany" реализаций. 

# Выполнение с ORM сессией
>[!ORM]
>Как упомянуто ранее, большинство шаблонов и примеров выше применяются для использования с ORM также, поэтому здесь мы расскажем об этом способе использования, чтобы по ходу обучения мы могли проиллюстрировать каждый шаблон с точки зрения совместного использования Core и ORM. 
>
>Фундаментальный интерактивный объект транзакций / базы данных при использовании ORM называемый [[Session]]. В современном SQLAlchemy, этот объект используется в способе очень схожем на [[Connectionn]], и фактически используется как [[Session]], это относится к внутреннему соединению, которое он использует для отправки SQL.
>
>Когда [[Session]] используется с не ORM конструкциями, она проходит через инструкции SQL, которые мы ему даем, и, как правило, не сильно отличается от того, как работает прямое соединение, поэтому мы можем проиллюстрировать это здесь с помощью простых текстовых операций SQL, которые мы уже изучили.
>
>У [[Session]] есть немного различных шаблонов создания, но здесь мы показываем один самый базовый, который точно отслеживает как используется [[Connectionn]], который спроектирован в области контекстного менеджера: 
>
>``` python
>>>> from sqlalchemy.orm import Session
>
>>>> stmt = text("SELECT x, y FROM some_table WHERE y > :y ORDER BY x, y")
>>>> with Session(engine) as session:
>...     result = session.execute(stmt, {"y": 6})
>...     for row in result:
>...         print(f"x: {row.x}  y: {row.y}")
>
>|------------------------------------------------------------------
>BEGIN (implicit)
>SELECT x, y FROM some_table WHERE y > ? ORDER BY x, y
>[...] (6,)
>|------------------------------------------------------------------
>
>x: 6  y: 8
>x: 9  y: 10
>x: 11  y: 12
>x: 13  y: 14
>|------------------------------------------------------------------
>ROLLBACK
>|------------------------------------------------------------------
>
> ```
>
>Пример выше может быть сравнен с примером в предшествующей секции [[#Отправка параметров]] - мы напрямую заменяем вызов `with engine.connect() as conn` на `with Session(engine) as session` и затем используем метод [[Session.execute()]] просто как мы делали с методом [[Connection.execute()]].
>
>Так же, как и [[Connectionn]], особенность [[Session]] использует поведение "commit as you go" методом [[Session.commit()]], продемонстрированный ниже используя текстовое выражение UPDATE для изменения некоторых наших данных:
>
>``` python
>>>> with Session(engine) as session:
>...     result = session.execute(
>...         text("UPDATE some_table SET y=:y WHERE x=:x"),
>...         [{"x": 9, "y": 11}, {"x": 13, "y": 15}],
>...     )
>...     session.commit()
>
>|------------------------------------------------------------------
>BEGIN (implicit)
>UPDATE some_table SET y=? WHERE x=?
>[...] [(11, 9), (15, 13)]
>COMMIT
>|------------------------------------------------------------------
>```
>
>Выше мы вызываем UPDATE выражение используя связанный параметр, “executemany” стиль выполнения предоставлен в [[#Отправка нескольких параметров]], завершаем блок “commit as you go” фиксацией.
>
>>[!TIP]
>>[[Session]] фактически не удерживает объект [[Connectionn]] после завершения транзакция. Он получает новый [[Connectionn]] из [[Engine]] в следующий раз для выполнения SQL в базе данных.
>
>[[Session]] очевидно имеет несколько больше трюков в рукаве, однако понимание того, что у него есть метод [[Session.execute()]] который используется также как и [[Connection.execute()]], который поможет нам начать с примеров следующих позднее.
>
>>[!Quote]
>> [[Базовое использование Session]] - предоставляет базовые паттерны создания и использования [[Session]] объекта.

Следующая секция руководства: Работа с метаданными базы данных