С объектом [[Engine]], готовым к работе, мы можем сейчас продолжить погрузиться в базовые операции с [[Engine]] и главными интерактивными конечными точками такими как [[Connectionn]] и [[Result]]. Мы будем дополнительно вводить ORM [[фасад]] для этих объектов, известный как [[Session]].

>[!ORM]
>При использовании ORM, [[Engine]] управляет другим объектом, называемым [[Session]]. [[Session]] в современной SQLAlchemy подчеркивает транзакционный и паттерн выполнения SQL, который значительно идентичен [[Connectionn]] обсужденный ниже, так пока эта подсекция ориентирована на Ядро, все концепты здесь по существу подходят для ORM использования и рекомендуется для всех ORM учащихся. Паттерн выполнения используемый [[Connectionn]] будет контрастировать с  [[Session]] в конце этого раздела.

Так как мы еще не успели представить язык выражений SQL, который основная особенность SQLAlchemy, мы будет использовать одну простую конструкцию в пределах этого пакета называемое [[text()]] конструкцией, которая позволяет нам писать SQL выражения как **текстовый SQL**. Будьте уверены, что текстовый SQL в повседневном использовании SQLAlchemy однозначно скорее исключение чем правило для большинства задач, даже несмотря на то, что он всегда остается полностью доступным.

> [!Core]
> # Получение подключения
> 
> Единственной целью объекта [[Engine]] из ориентированной на пользователя перспективе предоставить юнит соединения с базой данных, называемый [[Connectionn]].  При работе с ядром напрямую, объект [[Connectionn]] это как всё взаимодействуем с базой данных. Как [[Connectionn]] представляет открытый ресурс с базой данных, мы хотим всегда ограничить область нашего использования этого объекта определенным контекстом и лучший способ делать это используя форму контекст менеджера Python, так же известного как  [выражение with](https://docs.python.org/3/reference/compound_stmts.html#with).  Ниже мы показывает "Hello world" используя текстовое SQL выражение. Выпускаемый текстовый SQL  использует конструкцию называемую [[text()]] который будет обсуждаться в больших деталях позднее:
> ``` python
> 
>>>> from sqlalchemy import text
>
>>> with engine.connect() as conn:
...     result = conn.execute(text("select 'hello world'"))
...     print(result.all())
>----------------------------------------------------------------------
BEGIN (implicit)
select 'hello world'
[...] ()
>----------------------------------------------------------------------
>
[('hello world',)]
>
>----------------------------------------------------------------------
ROLLBACK
>----------------------------------------------------------------------
>```
> В примере выше, контекст менеджер предоставляет подключение к базе данных и так же оформляет внутреннюю операцию транзакции. Стандартное поведение Python DBAPI включает, что транзакция всегда в процессе; когда область подключения [[released]], ROLLBACK выполняется для окончания транзакции.  Транзакция **не совершается автоматически**; когда мы хотим зафиксировать данный мы обычно нуждается в вызове [[Connection.commit()]] как мы увидим в следующей секции.
> 
>> [!TIP]
>>Режим "autocommit" (автоматического фиксирования) доступен для особых случаев. Это обсуждается в секции  [[Setting Transaction Isolation Levels including DBAPI Autocommit]]
>
>Результат нашего SELECT будет так же возвращено в объекте называемым [[Result]], который будет обсужден позднее, однако на данный момент мы будем добавлять, что лучше всего обеспечит использование этого объекта  в области блока "connect" и не передается по наследству извне области нашего подключения.
>
>
>

>[!Core]
># Фиксирование изменений
>
>
>
>
>z

