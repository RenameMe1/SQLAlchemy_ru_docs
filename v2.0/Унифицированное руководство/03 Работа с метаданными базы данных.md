Когда двигатели и выполнение SQL выключены, мы готовы начать некоторую алхимию. Центральный элемент и SQLAlchemy Core и ORM это языка выражений SQL, который позволяет свободно составлять конструкции для SQL запросов. Основа для этих запросов это Python объекты, которые  представляют концепты базы данных такие как таблицы и колонны. Эти объекты совокупно известны как [[метаданные базы данных]]. 

Наиболее распространенные базовые объекты для метаданных базы данных в SQLAlchemy известны как [[MetaData]], [[Table]] и [[Column]]. Секции ниже будут показывать как эти объекты используются и в используется в обоих ориентированных на Core и ORM стилях.

>[!ORM]
ORM читатели, оставайтесь с нами!
>
Как с другими секциями, пользователи Core могут пропустить ORM секцию, но ORM пользователям лучше всего ознакомиться с этими объектами в обоих перспективах. Объект [[Table]] обсуждаемый здесь объявлен более косвенным (и также полностью Python типизирован) способом при использовании ORM, однако в конфигурации ORM все еще существует объект таблицы.  

# Настройка метаданных с объектами таблиц
>[!Core&ORM]

Когда мы работаем с реляционной базой данных, основная структура хранения данных которую мы запрашиваем из базы данных  известна как **таблица**. В SQLAlhchemy "таблица" базы данных в конечном счете представлена объектом Python названным аналогично - [[Table]].

Для начала использования языка выражений SQLAlchemy, нам нужно создать объект `Table`, который представляет все таблицы базы данных с которыми нам интересно работать. [[Table]] построена программно либо напрямую используя конструктор [[Table]] либо косвенно используя ORM Mapped классы (обсуждаемые позднее в [[Using ORM Declarative Froms to Define Table Metadata]]). Есть так же опция для загрузки некоторой или всей информации о таблице из существующей базы данных, называемая [[reflection]].

Какой бы вид подхода не использовался, мы всегда начинаем с коллекции, в которую мы разместим наши таблицы известные как объект [[MetaData]]. Этот объект по существу [[фасад]] вокруг Python словаря, который хранит набор [[Table]] объектов привязанных к их строковым именам. Пока ORM предоставляет некоторые варианты для получения этих коллекций, у нас всегда есть вариант просто создать одну напрямую, который выглядит как:

``` python
>>> from sqlalchemy import MetaData
>>> metadata_obj = MetaData()
```

Как только у нас есть объект [[Metadata]], мы можем объявить некоторые [[Table]] объекты. Это руководство будет начинаться с традиционной для SQLAlchemy модели руководства, у которой есть таблица называемая `user_account`, которая хранит, для примера, пользователей веб сайта и связанная таблица `address`, которая хранит адреса электронной почты связанные с строками в  таблице `user_account`.  Когда вовсе не используются декларативные ORM модели, мы строим каждый объект [[Table]] напрямую. обычно мы назначаем каждой из них переменную, которая будет использоваться для ссылки на таблицу в коде приложения:

``` python
>>> from sqlalchemy import Table, Column, Integer, String
>>> user_table = Table(
...     "user_account",
...     metadata_obj,
...     Column("id", Integer, primary_key=True),
...     Column("name", String(30)),
...     Column("fullname", String),
... )
```

С примером выше, когда мы хотим записать код, который ссылается на таблицу `user_account` в базе данных, мы будем использовать Python переменную `user_table` для ссылки на нее.

>[!QUOTE]
> ## Когда мне создавать `MetaData` объект в моей программе?
>Имейте один объект [[MetaData]] для всего приложения подходит для большинства случаев,  представленным как переменная уровня модуля в одном месте приложения, часто в пакете типа "models" или "dbschema". Так же очень распространено, что [[MetaData]] доступна через ORM ориентированный [[registry]] или базовый [[Declarative Database]] класс, так что это такая же [[MetaData]] общедоступная среди ORM и Core объявленных [[Table]] объектов
>
Также может быть несколько коллекций [[MetaData]]; объект [[Table]] может ссылаться на объекты [[Table]] в других коллекциях без ограничений. Однако, для групп объектов [[Table]] которые связаны друг с другом, а практике гораздо проще настроить их в рамках одной коллекции  [[MetaData]], как с точки зрения их объявления, так и с точки зрения того, что инструкции DDL (т.е. CREATE и DROP) выполняются в правильном порядке.

## Компоненты таблицы

Мы можем наблюдать, что конструкция [[Table]] написанная в Python схожа с SQL CREATE TABLE выражением; начиная с имени таблицы, затем перечисление каждой колонки, где каждая колонка имеет имя и тип данных. Объекты, которые мы используем выше:
- [[Table]] - представляет таблицу базы данных и назначает себя в коллекцию [[MetaData]] 
- [[Column]] -  представляет колонны в таблице базы данных, и назначает себя к объекту [[Table]]. [[Column]] обычно включает строковое имя и тип объекта. Коллекция [[Column]] объектов в условиях родительской [[Table]] обычно доступна через связанный массив расположенного в [[Table.c]]:

``` python 
>>> user_table.c.name
Column('name', String(length=30), table=<user_account>)

>>> user_table.c.keys()
['id', 'name', 'fullname']
```

- [[Integer]], [[String]] - эти классы представляют SQL тип данных и могут быть переданы [[Column]] с необходимостью создания экземпляра или без.  Выше мы хотим дать колонке длину в "30" и имя "name", так мы создали экземпляр `String(30)`. Но для “id” и “fullname” мы их не указали, поэтому мы можем отправить сам класс.

>[!QUOTE]
> # Смотрите также
> 
Справочная и API документация для [[MetaData]], [[Table]] и [[Column]] в [[Describing Database with MetaData]]. Справочная документация для типов данных в [[SQL Datatype Objects]].

В предстоящей секции, мы покажем [[Table]] одну из фундаментальных функций, которая генерирует [[DDL]] на определенном подключении к  базе данных. Но сначала мы объявим вторую [[Table]].

## Объявление простых ограничений

Первая [[Column]] в примере `user_table` включает параметр [[Column.primary_key]], который является сокращенным способом указания того, что эта [[Column]] должна быть частью первичного ключа для этой таблицы. Сам первичный ключ обычно объявляется косвенным образом и представляется конструкцией [[PrimaryKeyConstraint]], которую мы можем увидеть на атрибуте [[Table.primary_key]] объекта [[Table]]:

``` python

>>> user_table.primary_key
PrimaryKeyConstraint(Column(
		'id', 
		Integer(), 
		table=<user_account>,
		primary_key=True,
		nullable=False
		))
```

Ограничение которое наиболее часто объявляется явно - это объект [[ForeignKeyConstaint]], который соответствует [[foreign key constraint]] базы данных.